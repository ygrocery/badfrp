要点整合

python中数字有四种类型：
整数、布尔型、浮点数和复数
int (整数), 如 1, 可表示长整型，没有python2中的Long
bool (布尔), 如 True。
float (浮点数), 如 1.23、3E-2
complex (复数), 如 1 + 2j、 1.1 + 2.2j

标准数据类型
不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
可变数据   （3 个）：List（列表）、Dictionary（字典）、Set（集合）

========================基本要求
1. 编码
头部#-*-coding:utf-8-*-标识

2. 格式
2.1 统一使用4个空格作为缩进
2.2 每行代码尽量不超过80个字符，超出可用\换行
2.3 自然语言使用"...",
2.3 机器标识使用'...',例如dict中的key
2.3 正则表达式使用r"..."
2.3 文档字符串使用"""...."""
2.4 模块级函数和类之间空2行，类成员函数间空1行
2.5 不推荐import os,sys模块连写，建议分开写
2.5 可以from subprocess import Popen,pipe
2.6 在二元运算符两边各空1格



========================字符串拼接
longStr=''
shortStrs=[str1,str2,..,strN]
for S in shortStrs:
    longStr += S
谨记python中字符串是不可变的，所以每次循环
都是讲原来的longStr和str拷贝成新字符串，随着longStr不断增长，
需要拷贝的内容就越来越长，这显然不是一个好主意。
推荐：longStr = ''.join(shortStrs)


========================列表操作
extend() 追加末尾，接受参数是list，相当于shell中的"$@"
append() 最佳末尾，接受任何数据类型，接受list相当shell中的"$*"



========================元组
一旦初始化就不能更改，但可以切片获取元素

定义1个元素时t = (1,)需要末尾加逗号，否则表达数学意义上的括号
tuple所谓的不变是指，元素的指向不变，特例:包含列表元素
所以要创建列表内容不变，需要保证每个元素本身不变

tuple比list操作速度快
若需定义一个值的常量集，且需要不断遍历，请使用tuple

因为不可修改，相当于“写保护”
使用tuple如同list拥有一个隐含的assert语句，若必须修改,list()转换

tuple可以作为dictionary的key,但list不可以

函数return多值就是tuple应用,函数若要同时接受多个变量值可以用tuple


========================字典
dict在其他语言中一般称为map,键-值key-value存储，极快的查找速度

#预防空值报错
d = {'t1':1,'t2':2,'t3':3}
#删除元素
d.pop('t1')
print(d)
#print(d['t1'])
#空值默认返回None，可以设置默认值
print(d.get('t1'))


========================集合
#set只能嵌套1个元素，嵌套多为list，tuple
#其中嵌套tuple显示效果同{}
#set()表示空集，而{}表示空字典
#s = set(['ni','wo','ta'])
s = set(['ni','wo','ta'])
s.add(4)
s.add(4)
s.remove(4)
print(s)


========================参数
#位置参数(必选参数)
def power(x,n):
    s = 1
    while n > 0:
        n = n =1
        s = s * x
    return s
power(5,2)

#默认参数
#默认参数必须是指向不变对象
def add_end(L=[]):
    L.append('END')
    return  L
print(add_end())
print(add_end())
#参数可以改进，用None
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

#可变参数
#可变参数和定义1个list或tuple参数相比，只需在参数前加1个*号
#可变参数允许传入0个或任意个参数，在函数调用时自动组装成tuple
#def calc(num):
#print(calc((1,2)))
def calc(*num):
    sum = 0
    for n in  num:
        sum = sum + n * n
    return sum
#1# 传入参数
print(calc(1,2))
#若是已经存在list或tuple，需要传入则：
#num = [1,2]
#1# clac(num[0],num[1])
#2# calc(*num)

#关键字参数
#功能和可变参数相同，但是它在函数内部组装成dict
#它可以扩展函数功能，例如调用者愿意提供非必须信息
#定义方式def test(**key)
#若是要传入一个字典，则test(**dict1)


#命名关键字参数
#对于关键字参数，调用者可以传入任意参数，但是命名关键字可以进行限制
#def person(name, age, *, city='shenzhen', job='engineer')
#以上就是关键字的模板，需要一个*作为分隔符,否则就是位置参数
#若是不输入命名关键字参数，且没有默认参数则会报错

#参数组合
#顺序：必选参数、默认参数、可变参数/命名关键字参数、关键字参数
#对于任意函数，都可以通过func(*args,**kw)调用
#对于可变参数，建议组装成list或tuple，然后通过*args传入
#对于关键字参数，建议先组装成dict，然后通过**kw传入



========================函数

#递归函数
#一个函数内部调用自身，这就是递归函数
#fact(n)=n!=(n-1)!*n=fact(n-1)*n
#由上推理可得，当阶乘n=1时需要特殊处理
def fact(n):
    if n==1:
        return 1
    return n * fact(n-1)
#递归都可以改成循环，但递归定义简单，逻辑清晰
#函数调用时通过栈stack数据结构实现的
#每进入1个函数调用，栈就会加1层;函数返回，栈就减1层
#由此栈大小非无线，需要防止栈溢出

#尾递归函数
#可通过尾递归优化，类似与循环，而循环可看做特殊的尾递归
#在函数返回调用自身，且return不能包含表达式，编译器优化调用
#使得调用的时候，都只占用一个栈帧，不会出现栈溢出
def fact(n):
    return fact_iter(n,1)
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num -1, num * product)
#num -1和num * product函数调用前被计算了，所以仅返回递归函数本身
print(fact(3))
print(fact_iter(3,1))
#但是大多数语言没有针对尾递归优化，而python解释器也没有

偏函数
#functools模块提供很多有用功能
def int2(x, base=2):
    return int(x, base)
#改进
import functools
int2 = functools.partial(int, base=2)
print(int2('1010001'))
print(int2('10101010'))
#作用：把一个函数某些参数固定，返回新的函数，简化操作
#有点像数据库中定义存储过程



========================高阶函数
函数式编程
#functional programming，接近于抽象的数学计算
#记住一点越是抽象的计算就离计算机硬件越远
#特点：允许把函数本身作为参数传入到另一个函数，允许返回一个函数
#python允许使用变量，因此不是纯函数式编程语言
高阶函数
#特性： 1.变量可以指向函数；2.函数名也是变量
#一个函数可以接受另一个函数作为参数，这种函数就称为高阶函数
#函数式编程就是指这种高度抽象的编程范式
def add(x,y,f):
    return f(x) + f(y)
print(add(-3,9,abs))

#高阶函数--map函数
#传入两个参数、1.函数；2.Iterable
#将传入的函数依次作用到每个元素，并发结果作为新的Iterator返回
def f(x):
    return x * x
list1 = [x for x in range(1,10)]
#因为iterator是惰性序列，所以需要通过list()函数计算，并返回list
r = map(f, list1)
print(list(r))
#结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]
#这就是将循环代码抽象化，使代码逻辑清晰
print(list(map(str,[1,2,3,4,5])))

#高阶函数--filter函数
#传入两个参数、1.函数；2.序列
#将传入的函数依次作用到每个元素，根据返回值true or false保留or丢弃
def not_empty(s):
    return s and s.strip()
print(list(filter(not_empty, ['a','','b',None,' '])))
#计算素数
# 定义1个从3开始的奇数序列
def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield  n
def _not_divisible(n):
    return  lambda x: x % n > 0
def primes():
    yield 2
    it = _odd_iter()
    while True:
        n = next(it)
        yield  n
        it = filter(_not_divisible(n), it)
for n in primes():
    if n < 20:
        print(n)
    else:
        break


#高阶函数--reduce函数
#传入两个参数、1.函数；2.序列
#将传入的序列和函数递归累计算
from functools import reduce
def fn(x,y):
    return x * 10 + y
print(reduce(fn, [1,2,3,4]))
#假如python没有提供int()函数，我们可以自己写一个
from functools import reduce
def str2int(s):
    def fn(x,y):
        return x * 10 + y
    def char2num(s):
        return {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]
    return reduce(fn, map(char2num, s))
print(str2int('3523'))


#高阶函数--sorted函数
#用于字符串、dict排序
#支持接收1个key函数来自定义排序
#默认情况下对字符串排序按照ascii大小比较
print(sorted(['lingyi','Fengjie','huangzhi','Wenqiang']))
#不区分大小写
print(sorted(['lingyi','Fengjie','huangzhi','Wenqiang'], key=str.lower))
#排序翻转
print(sorted(['lingyi','Fengjie','huangzhi','Wenqiang'],reverse=True))


lambda函数--匿名函数
#传入函数不需要显式定义函数时
from functools import reduce
def char2num(s):
    return {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}[s]
def str2int(s):
    return reduce(lambda x,y: x * 10 + y, map(char2num,s))
print(str2int('3523'))
#lambda x,y: x *10 + y实际上就是
def f(x,y):
    return x *10 + y
#匿名函数只能有一个表达式，返回值就是该表达式的结果


返回函数
#一个函数的返回值返回一个函数

#返回函数--闭包函数
#lazy_sum中定义sum函数，它引用了lazy_sum的参数和局部变量
#当lazy_sum返回函数sum时，相关参数和变量保存在返回函数中
#这被称为“闭包”closure
#
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax 
    return sum
f = lazy_sum(1,3,5,7,9)
#调用函数才是计算结果
print(f())
#返回函数不要引用任何循环变量，或后续会发生变化的变量
#如果一定要用，则再创建一个函数，用该函数参数绑定循环变量当前的值
#缺点是代码过长，可以利用lambda缩短代码
def count():
    def f(j):
        def g():
            return j * j
        return g
    fs = []
    for i in range(1,4):
        fs.append(f(i))
    return fs
f1,f2,f3 = count()
print(f1(),f2(),f3())



#返回函数--装饰器
#函数是一个对象，而且函数对象可以被赋值给变量
#函数对象有__name__属性，可以拿到函数名字
def now():
    print('hello')
f = now
f()
print('now:',now.__name__,'f:',f.__name__)
#在代码运行期间动态增加功能的方式称为装饰器decorator
#定义log，他是一个装饰器，所以接受一个函数作为参数并返回一个函数
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
#@log放到now()定义处，相当于now = log(now)
@log
def now():
    print('hello world')
now()
#从now编程wrapper
print(now.__name__)
#这样一来函数签名的代码执行就会出错！
#wrapper.__name__ = func.__name__这样补充回去
#python内置functools.wraps就处理这个

#若是decorator本身需要传入参数，则需要返回装饰器的高阶函数
#比如定义log文本
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' %(text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
#相当于now = log('execute')(now)
@log('execute')
def now():
    print('third test')
now()
print(now.__name__)
#在面向对象OOP设计模式中，decorator称为装饰模式
#它需要通过集成和组合来实现，python的能用函数实现、类实现



========================方法
显示对象的属性，如果没有提供参数，则显示全局变量的名字
dir([obj])

查看python中的保留字
import keyword
keyword.kwlist

查看内置函数
https://docs.python.org/3/library/functions.html

切片
#对于经常指定索引范围操作，循环十分繁琐，所以提供了切片
#切片左边是闭区间，右边是开区间，所以不包含末尾数
L=list(range(100))
r=[]
n = 3
for i in range(n):
    r.append(L[i])
print(r)
print(L[0:3])


判断对象类型
x = 'abc'
print(type(x))
print(isinstance(x,str))
#isinstance 和 type 的区别在于：
#type()不会认为子类是一种父类类型。
#isinstance()会认为子类是一种父类类型。
class A:
    pass
class B(A):
    pass
print(isinstance(A(), A))
print(type(A()) == A)
print(isinstance(B(), A))
print(type(B()) == A)


迭代
#可以通过for..in遍历的都称为迭代Iteration
#python的for循环抽象程度要高于Java(迭代需要下标)
#因为它可以作用于list,tuple之外的其他可迭代对象
for cha in 'abc':
    print(cha)
#实现Java类似的下标循环
for i, value in enumerate(['a','b','c']):
    print(i,value)
#在for循环里同时引用两个变量，在python中很常见
for x,y in [(1,1),(2,4),(3,9)]:
    print(x,y)
#for循环数据类型，统称为可迭代对象Iterable
#1类：集合数据类型；list/tuple/dict/set/str等
#2类：generator类；包括生成器和带有yield的generator function
#将1类的list,dict,str这些iterable变成iterator可以用iter()函数
#iterator是惰性计算，不知道序列长度
#判断可迭代对象
#误区1：可迭代不一定是可切片
from _collections_abc import Iterable
print(isinstance('f', Iterable))
print(isinstance([1,2,3],Iterable))
print(isinstance(123,Iterable))
print(isinstance({1,2,3},Iterable))
#判断迭代器
#生成器不但可以用作for循环，还可以被next()不断调用并返回值
#直到最后抛出stopiteration错误表示无法继续返值
#误区2: 只有能被next()函数调用并返回下一个值的对象才是迭代器
from _collections_abc import Iterator
x = (x * x for x in range(2))
print(type(x))
print(isinstance(x,Iterator))
list1 = [1,2,3]
print(isinstance(list1,Iterator))
print(isinstance(iter(list1),Iterator))


列表生成式
#原始方法
L = []
for x in range(1,11)
    L.append(x * x)
print(L)
#一句话代替
[x * x for x in range(1,11)]
#可以加上if判断
print([x * x for x in range(1,11) if x % 2 ==0])
L = ['Hello', 'World', 18, 'Apple',None]
print([s.lower() for s in L if isinstance(s, str)])
#可以多层循环
[m + n for m in '123' for n in '456']
#将两个变量生成list
print([k + '=' + v for k, v in {'a':'b','c':'d','e':'f'}.items()])


生成器
#为了节省内存空间，而不创建完整的list
#这种一边循环，一遍计算的机制称为generator
#将列表生成器的[]改成()就能创建一个生成器
g = (x * x for x in range(2))
print(g)
#返值: <generator object <genexpr> at 0x000002193C02F750>
#通过next()获取生成器的值
print(next(g))
print(next(g))
print(next(g))
#直到计算到最后1个元素，将会抛出StopIteration错误
#基本上不用next()，而是用for循环，并且不用担心错误
for n in g:
    print(n)
#斐波拉数列用列表生成器无法实现，但可以用函数实现
#generator与函数执行流程不一样，遇到yield返回,每次调用next()执行
def fib(max):
    n,a,b = 0,0,1
    while n < max:
        yield b
        a,b = b, a+b
        n = n + 1
    return 'done'
#错误示范：f = fib(6); print(f)
for n in fib(6):
    print(n)
#因为他是generator，所以获取不了return语句
#若想要返回值，需要捕捉StopIteration错误
g = fib(6)
while True:
    try:
        x = next(g)
        print('g:', x)
    except StopIteration as e:
        print('Generator return value:', e.value)
        break


模块介绍
#python引入按目录来组织模块的方法，称为包package
#第三方木块路径添加
import sys
sys.path.append('your/path')
#第二种是修改环境变量pythonpath

面向对象
#首先考虑的不是程序的执行流程
#比如学生这个数据类型应该视为一个对象
#该对象拥有name和score这两个属性
#object类是所有类最终都会继承的类，可不填
#__init__第一个参数表示创建的实例本身
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def print_score(self):
        print('%s: %s' %(self.name, self.score))
#给对象发消息实际上就是调用对象对应的关联函数
#称之为对象的方法method
#面向对象的程序如下
bart = Student('Bart Simpson', 59)
lisa = Student('Lisa simpson', 97)
bart.print_score()
lisa.print_score()
#和静态语言不通，python允许对实例绑定任何数据
bart.age = 8
print(bart.age)
#如果想要限制外部修改和访问内部变量
#则可以将name，score改成__name,__score
#外部需要获取name和score变量值要如何？
#可以在内部定义函数
def get_name(self):
    return self.__name
def get_score(self):
    return self.__score
#如果后面改需求，需要修改内部变量，则方法同上
def set_score(self,score):
    if 0 <= score <= 100:
        self.__score = score
    else:
        raise ValueError('bad score')
#有时候你会看到一个下划线_开头的变量
#表示尽管可以被访问，但请不要随意访问
#那么__name是否真的不可以访问？
#其实不是的，它只是被解释器改成_Student__name
#所以可以通过_Student__name访问
#但是建议你不要这样做，因为解释权归python解释器所有


继承和多态
#继承是类中的方法，类似于函数中的装饰器
#多态是子类方法覆盖父类方法，相当于是后代变异














